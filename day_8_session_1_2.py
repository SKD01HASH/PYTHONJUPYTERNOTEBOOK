# -*- coding: utf-8 -*-
"""Day-8-Session-1-2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tG6WSN4hWWK0Ybq9rJRGeGhbYxD8kRXV

# Classes and OOP Examples
"""

import math
class ComplexNum(object):
    """A class to implement complex numbers"""
    # real and imaginary parts are stored in real and imag
    def __init__(self, r=0, i=0):  # self is equivalent of "this" in Java and C++
        # complex number, given real and imaginary part
        # defaults to create 0 + i0
        self.real = r  # self equiv to "this" in java/C++
        self.imag = i

    def __str__(self):
        """ Returns a string representation of the complex number"""
        # printed as {x + jy} or {x - jy}
        imag = self.imag
        join = ' +'
        if (imag < 0):
            imag = -imag
            join = ' -'
        return '{' + str(self.real) + join +' j' + str(imag) + '}'

    def getReal(self):
        """ Returns the real part"""
        return self.real

    def getImag(self):
        """ Returns the imaginary part"""
        return self.imag

    def abs(self):
        """ return the magnitude """
        return math.sqrt(self.real*self.real + self.imag*self.imag)

    def conjugate(self):
        """ return the conjugate """
        return ComplexNum(self.real, -self.imag)

    def __add__(self, c2): # op+ 
        return ComplexNum(self.real+c2.real, self.imag+c2.imag)

    def __sub__(self, oth):
        return ComplexNum(self.real-oth.real, self.imag-oth.imag)

    def __mul__(self, oth):
        return ComplexNum(self.real*oth.real - self.imag*oth.imag,
                          self.real*oth.imag + self.imag*oth.real)

    
    def __truediv__(self, oth):
        othc = oth.conjugate()
        absSq = oth.abs()
        absSq = absSq * absSq
        
        numr = self * othc
        try:
            return ComplexNum(numr.real/absSq, numr.imag/absSq)
        except:
            raise ValueError("Divison by " + str(oth) + " not defined")

def testComplexNumber():
    z1 = ComplexNum()   # __init__(self, 0, 0) => 0 + i0
    z2 = ComplexNum(2, 3) # __init__(self, 2,3) => 2 +i3
    z3 = z2.conjugate() # conjugate(self) => Conjugate(z2) => 2 - i3
    # assert z3 == ComplexNum(2, -3), "Some Problem in Conjugate Compute"
    z4 = z2 * z3 ## __mul__(z2, z3)
    z5 = ComplexNum(3.5, 0.33)
    print ('z1 = ', z1)
    print ('z2 = ', z2)
    print ('Conjugate of ', z2, ' = ', z3)
    print (z2, ' * ', z3, ' = ', z4)
    print (z2, ' * ', z2, ' = ', z2*z2)
    print (z2, ' + ', z5, ' = ', z2+z5) # __add__ ( self=>z2, oth => z5)
    print (z5, ' - ', z2, ' = ', z5-z2)
    print (z5, ' / ', z2, ' = ', z5/z2)
    try:
        print (z5, ' / ', z1, ' = ', z5/z1)
    except ValueError as e:
        print(z5, ' / ', z1, ' = ', 'Expected exception:', e)

testComplexNumber()

"""# OOP: Inheritance

---

Bank Employees and Customers
"""

#
# The Person class is taken from "Introduction to Computation and
# Programming using Python", by John V Guttag
# Other classes are created by Amey Karkare, but inspired by the
# examples from the same textbook
#
import datetime

class Person(object):

    def __init__(self, name):
        """Create a Person"""
        self.name = name
        try:
            lastBlank = name.rindex(' ')
            self.lastName = name[lastBlank+1:]
        except:
            self.lastName = name
        self.birthdate = None

    def getName(self):
        """Return self's full name"""
        return self.name
    
    def getLastName(self):
        """Return self's last name"""
        return self.lastName

    def setBirthday(self, birthdate):
        """Asume birthdate is of type datetime.date
           Sets self's birthday to birthdate"""
        self.birthdate = birthdate

    def getAge(self):
        """Returns self's current age in days"""
        if self.birthdate == None:
            raise ValueError ('Birthdate not set for ' + self.name)
        return (datetime.date.today() - self.birthdate).days
    
    def __lt__(self, other):
        """Returns True us self's name is lexicographically
           less than other's name, and False otherwise"""
        if self.lastName == other.lastName:
            return self.name < other.name
        return self.lastName < other.lastName

    def __str__(self):
        """Return self's name"""
        return self.name

me = Person('Amey Karkare')
cat = Person('Garfield')
bat = Person('Bruce Wayne')
bat.setBirthday(datetime.date(1939, 5, 27))
cat.setBirthday(datetime.date(1978, 6, 19))

print(me)
print(cat)
print(bat)

def testPerson():
    pList = [me, cat, bat]
    for p in pList:
        print (p)
    print('===  Sorted ===')
    pList.sort()
    for p in pList:
        print (p)

testPerson()

class BankPerson(Person):
    # This is a class specific variable, shared by all objects
    # of the class 
    nextId = 0 # identification of BankPerson

    def __init__(self, name):
        Person.__init__(self, name)
        self.id = BankPerson.nextId
        BankPerson.nextId += 1;

    def getId(self):
        return self.id

    def __lt__(self, other):
        return self.id < other.id

    # An  alternate would  be to  have a  definition in  Customer
    # class  (return   True)  and   in  Employee   class  (return
    # False). But, if we later add any new subclass of BankPerson,
    # we must remember to have  a definition there too.  The
    # method below will work even when we add a new subclass.
    def isCustomer(self):
        return isinstance(self, Customer)

def testBankPerson():
    p1 = Person("Amey Karkare")
    p2 = BankPerson("Sachin T")
    p3 = BankPerson("Amey Karkare")
    p4 = BankPerson("Vijay M")
    print ('p2 is', p2)
    print ('Id of p3 is', p3.getId())
    print ('Id of p4 is', p4.getId())
    print ('p2 < p3 is', p2 < p3)
    print ('p4 < p3 is', p4 < p3)
    print ('p1 < p3 is', p1 < p3)  # < (p1, p3) => __lt__(p1, p3)
    print ('p1 < p4 is', p1 < p4)
    try:
        print('p4 < p1 is', p4 < p1)  # < (p4, p1) -=> p4.__lt__(p1) => __lt__(p4, p1)
    except:
        print("Expected Failure since p4.< requires p1.id")

testBankPerson()

class Customer(BankPerson):
    """A customer is a person holding an account in bank"""
    def __init__(self, name):
        BankPerson.__init__(self, name)
        self.savings = [] # list of savings accounts
        self.FDs     = [] # list of fixed deposits

    def addSavingsAcc(self, acc):
        self.savings.append(acc)

    def addFD(self, fd):
        self.FDs.append(fd)

    def removeFD(self, fd):
        self.FDs.remove(fd)

    # creates a clone of the arg, and returns the clone after
    # sorting
    #
    # Note the naming convention: A class member with a name
    # starting with underscore (_) is considered private.  This
    # is just a convention
    def _clone_and_sort(self, acc):
        clone = acc[:]
        clone.sort()
        return clone

    # generator version of _clone_and_sort
    def _clone_and_sort_g(self, acc):
        acc.sort()
        for a in acc:
            yield a
            
    # The following methods use a clone to avoid unintentional
    # modification
    def getSavingsAcc(self):
        return self._clone_and_sort(self.savings)
    
    def getFDs(self):
        return self._clone_and_sort(self.FDs)
        
    # The following methods are generator methods for above
    def getSavingsAcc_g(self):
        return self._clone_and_sort_g(self.savings)
    
    def getFDs_g(self):
        return self._clone_and_sort_g(self.FDs)

def testCustomer():
    p1 = Person("Amey Karkare")
    p2 = Customer("P Mukherjee")
    p3 = Customer("Amey Karkare")
    p4 = Customer("Vijay M")

    print ('p2 is', p2)
    print ('Id of p3 is', p3.getId())
    print ('Id of p4 is', p4.getId())
    print ('p2 < p3 is', p2 < p3)
    print ('p4 < p3 is', p4 < p3)
    print ('p1 < p3 is', p1 < p3)

    p2.addSavingsAcc(23)
    p3.addSavingsAcc(24)
    p4.addSavingsAcc(42)
    p2.addSavingsAcc(237)
    p2.addSavingsAcc(871)

    p3.addFD(32)
    p2.addFD(25)
    p4.addFD(45)
    p4.addFD(109)
    sv = p2.getSavingsAcc()
    sv[1] = 0
    print(p2, sv)
    pList = [p1, p2, p3, p4]
    for p in pList:
        if (type(p) == Customer):
            print ('-----------------------------------------------------')
            print ('For customer', p)
            print ('\tSavings Accounts :', p.getSavingsAcc())
            print ('\tFixed Deposits   :', p.getFDs())

testCustomer()

class NormalCustomer(Customer):
    """Normal customer does not have anything extra over
       Customer. However, creating a separate class allow us to
       manage things in case things change in future"""
    pass

# NOTE THE USE OF pass. Why is it needed?

class PremiumCustomer(Customer):
    """Customer with a dedicated relationship manager"""
    def __init__(self, name, relManager):
        Customer.__init__(self, name)
        self.relManager = relManager
    def getRelationshipManager(self):
        return self.relManager

class Employee(BankPerson):
    """Should containg Employee specific attributes. Ignoring for the
       class purpose"""
    pass

def testSubCustomer():
    p1 = BankPerson("Amey Karkare")
    p2 = PremiumCustomer("P Mukherjee", "Manager 1")
    p3 = NormalCustomer("Amey Karkare")
    p4 = PremiumCustomer("Vijay M", "Manager 2")

    print ('p2 is', p2)
    print ('Id of p3 is', p3.getId())
    print ('Id of p4 is', p4.getId())
    print ('p2 < p3 is', p2 < p3)
    print ('p4 < p3 is', p4 < p3)
    print ('p1 < p3 is', p1 < p3)

    p2.addSavingsAcc(23)
    p3.addSavingsAcc(24)
    p4.addSavingsAcc(42)
    p2.addSavingsAcc(237)
    p2.addSavingsAcc(871)

    p3.addFD(32)
    p2.addFD(25)
    p4.addFD(45)
    p4.addFD(109)

    pList = [p1, p2, p3, p4]
    for p in pList:
        if (p.isCustomer()):
            print ('-----------------------------------------------------')
            print ('For customer', p)
            print ('\tSavings Accounts   :', p.getSavingsAcc())
            print ('\tFixed Deposits     :', p.getFDs())
            if (type(p) == PremiumCustomer):
                print ("\tRelation's Manager :", p.getRelationshipManager())

# Generator version testing.
def testSubCustomer_g():
    p1 = BankPerson("Amey Karkare")
    p2 = PremiumCustomer("P Mukherjee", "Manager 1")
    p3 = NormalCustomer("Amey Karkare")
    p4 = PremiumCustomer("Vijay M", "Manager 2")

    p2.addSavingsAcc(23)
    p3.addSavingsAcc(24)
    p4.addSavingsAcc(42)
    p2.addSavingsAcc(237)
    p2.addSavingsAcc(871)

    p3.addFD(32)
    p2.addFD(25)
    p4.addFD(45)
    p4.addFD(109)

    pList = [p1, p2, p3, p4]
    for p in pList:
        if (p.isCustomer()):
            print ('-----------------------------------------------------')
            print ('For customer', p)
            print ('\tSavings Accounts   :', end=' ')
            for s in p.getSavingsAcc_g():
                print (s,end=' ')
            print()
            print ('\tFixed Deposits     :', end = ' ')
            for s in p.getFDs_g():
                print (s,end=' ')
            print()
            if (type(p) == PremiumCustomer):
                print ("\tRelation's Manager :", p.getRelationshipManager())

testSubCustomer()

testSubCustomer_g()

"""#Iterators"""

for element in [1, 2, 3]:
    print (element)
for element in (1, 2, 3):
    print (element)
for key in {'one':1, 'two':2}:
    print (key)
for char in "123":
    print (char)
#for line in open("myfile.txt"):
#    print (line)

s = 'ab_c_d'

it = iter(s)
it

next(it)

next(it)

next(it)

next(it)

class Reverse:
  """Iterator for looping over a sequence backwards."""
  
  def __init__(self, data):
    self.data = data
    self.index = len(data)
  
  def __iter__(self):
    return self

  def __next__(self):
    if self.index == 0:
      raise StopIteration
    self.index = self.index - 1
    return self.data[self.index]

rev = Reverse('12345')

for char in rev:
  print(char)

r = Reverse('spam')

char = iter(r)

while True:
  try:
    nxt = next(char)
    print(nxt)
  except StopIteration:
    break

x = 4+9
4+2
print('Hello')